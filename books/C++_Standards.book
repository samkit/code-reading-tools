Title: C++ International Standard (Working Draft, Standard for Programming Language C++)
Document number: N3337
Type: Ebook
Source: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf

Chapter 1 - General
    
Chapter 14 - Templates
    14.1 - Pg.304
        4. Non-type template parameter:
            integral / enumeration type
            pointer to object / pointer to function
            lvalue reference to object / lvalue reference to function
            pointer to member
            std::nullptr
        6. Address of non-type non-reference type cannot be taken or its value cannot be changed.
           But when const reference is created to it, then a temporary is created.
        10. Default arguments for are constructed by merging all defaults in all declarations.
            Like:
                template <class T1, class T2 = int> class A;
                template <class T1 = int, class T2> class A;
            is equivalent to
                template <class T1 = int, class T2 = int> class A;
        14. Default argument for template-template template parameter is only applicable in declaration scope.
            Eg: Pg. 306
        15. Template parameter pack cannot be expanded in same template declaration.

    14.2 - Pg.307
        4. Template specialization appearing after . / -> should have `template' keyword.
           Eg: p.template alloc<200>();     - Pg.308

    14.3 - Template arguments - Pg.308
        2. If a template is overloaded with type-id and non-type parameters, then type-id version is selected.
        5. Explicit destructor call should specify template arguments explicitly.
        7. When template parameter does not match for overloaded template function, then that is ignored.

        14.3.1 - Template type arguments
            2. A template type argument can be an incomplete type.
        14.3.2 - Template non-type arguments
            1. Valid argument:
                - a constant expression which is
                    * address of static duration object - external / internal linkage
                    * function with external / internal linkage
                    * function templates
                    * not non-static class member - either reference or pointer (see 3)
            2. String literals are not qualified for template parameter.
            4. Reference type template-parameter cannot bind to temporary-unnamed-lvalue or lvalue-with-no-linkage.
            5. Pointer to [member] function goes through overload resolution rule when given as a template argument.
        14.3.3 - Template template argument
            2. When considering template-template argument then primary class template is checked against without considering default parameter.
               Template parameter pack does not match strict template-template parameter. For eg:
               template <class...> class C;
               template <template <class> V> class X;
               X<C> x;      // ill-formed
            3. Template-template argument match examples. Pg.314
        14.5 - Template declarations
